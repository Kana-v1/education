Dependability is: availability, reliability, and maintainability.

Dependability attributes:
 - Fault Prevention -> avoid of the occurrence or introduction of faults
 - Fault Tolerance (self-healing, etc) -> avoid service failures in the presence of faults, 
 	обычно добавляют софт для хила и запасные сервисы
 - Fault Removal -> reduce the number and severity of faults
 - Fault Forecasting -> identify the presence, the creation, and the consequences of faults

Dependability procurement - уверенность которую получает возможность системы выполнять функции для которых она(система) предназначена

Варианты поиска косяков в софте: 
 - Статический анализ -> скрипты не запускают программу, но пытаются найти косяки (юнит-тесты, линтеры, etc)
 - Динамический анализ -> aka testing
 
 12 правил веб софта:
 
 1) Codebase 
  Весь прод должен идти с одной и той же кодовой базы. По факту все должны брать и обновлять код из одного и того же репозитория
 
 2) Dependencies
  Тут зависимости имеется в виду модули/пакеты. Т.е. система не должна навернутся от того что версия какого-то там пакета поменялась
  
 3) Configuration
  Конфиги должны быть отделены от кода (короче, используйте env файлы)
  
 4) Backing Services
   Не должно быть разного отношения к своим и 3rd party сервисам
 
 5) Build, Release, Run
  Эти шаги стоит так разделять чтобы можно было повторить каждый отдельный шаг без особых проблем
  
 6) Processes
  Сервисы сами по себе не должны хранить данные (если нужно сохранить данные - это в бд, кеш, etc)
  
 7) Data isolation 
  Один сервис не должен влезать в другой. Для таких целей есть api, rpc, pub-sub
 
 8) Scalability
  Сервисы должны уметь горизонтально масштабироваться
  
 9) Disposability
  Сервисы должны уметь нормально запускаться и останавливаться вне зависимости от причин остановки (если бек падает в панику от того что в бд нет значений это очень так себе)
  
 10) Development/Production parity
  Прод и дев части должны быть максимально одинаковыми (одинаковый код, стек, по хорошему те кто писал код должны сами его деплоить)
  
 11) Logs
  Логи должны лететь в stdout, а не в локальный файл который потом невозможно найти
 
 12) Administrative processes
  Админские цели супер нежелательно делать руками. Т.е. делать миграции написав на проде это все руками затея отнюдь не из лучших 
  
 Scalability - возможность резко увеличить пропускную способность сервисов т.к. держать 20 серверов когда постоянно используется 3 просто дорого, но если есть момент когда нужно 20 - значит должны быть возможность увеличить их количество
 
 resource state - данные которые одинаковые для каждого клиента и которые не взаимодействуют напрямую с клиентом

application state - это данные которые лежат внутри самого приложения (не в бд), такие данные делают приложение не масштабируемым

Durability - данные которые лежат в одном месте (например без реплики) когда-нибудь потеряются.

Cacheability - stateless сервисы идемпотентны, так что их ответы можно положить в кеш и ускорить последующие ответы сервиса

coupling

способы получить tight coupling:
1) самый дефолтный - напрямую лезть в другой сервис
2) сервисы которые должны использовать определенную либу, или определенную версию этой либы
3) ответ от другого сервиса. Сам по себе такой паттерн не плох, но лучше юзать паб-саб для подобных вещей, или хотя бы обрабатывать невалидный ответ от сервиса
4) жестко заданный адрес другого сервиса (будет грустно если бд переедет на другой айпишник и это уложит все сервисы потому что они в миллионе разных мест захардкоили ее айпи)

GraphQL - альтернатива РЕСТу

Remote Procedure Calls (RPC) - позволяет выполнять процедуры в другом неймспейсе (обычно на другом компе). gRPC - одна из реализаций

gRPC: в keyValue.proto все методы это примеры унарного типа, по которым клиент кидает одиночный запрос на сервер и сервер возвращает одиночный ответ. Всего типов 4 и такой - самый простой

Чтобы превратить .proto файл в го ->
    
protoc --go_out=./gRPCtemplate --go_opt=paths=source_relative     --go-grpc_out=./gRPCtemplate --go-grpc_opt=paths=source_relative  keyValue.proto








 
 
  
 
